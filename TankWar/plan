项目计划：
1、首先完成Model层对于各种操作，如移动，发送子弹等等的逻辑操作。按照MVC的设计理念，所有的逻辑操作都需要放在Model层执行。
2、然后实现Model层到view层的通知或者发布，既可以使用Observer-Observable实现，也可以参考PIPE是使用publisher-subscribe实现。
3、最后在实现view层上，各种view panel的移动和显示。

8.25号：
一、实现Model层的逻辑
1、首先实现TankModel和StoneModel
2、然后实现一些基本操作譬如坦克移动，子弹移动和坦克攻击等在Model层的逻辑操作
3、进一步实现全部的Model层的逻辑操作，暂时能想到的有开启游戏（可能会包含生成地图）、结束游戏（需要关闭相应的线程）
4、至此完成Model层的逻辑

////////////////////////

8.26号、9.1号：
一、继续实现Model层的逻辑
1、首先补充完成TankModel和StoneModel，根据不同的坦克种类，攻击值、防御值、速度等都会有一个固定值。
	同时生成坦克或者子弹时也是通过工厂方法，批量生成不同的坦克。
	另外，坦克的position不应该只是一个点，应该需要做成一个面积，如一个格子的大小。
		  子弹的话，也可以做成面积，如长的一边为1/4格子，短的一边为1/8格子的大小。
		 根据面积是否发生重叠来判断，是否碰到一起。


		 
2、主要的逻辑处理还是在GameModel中，因为GameModel包括全部的属性，如坦克列表、子弹列表、地图，因此只有GameModel有能力判断。
	如电脑坦克移动，    需要判断与它同一行或者同一列是否可以攻击到用户坦克，
						如可以攻击到，则进行攻击，如方向不对，则需要变化方向；
					
					还需要判断是否撞到障碍物，如果撞到障碍物，则需要转向。

9.1号添加：对于坦克和子弹相撞问题，确定是由坦克去处理，子弹不判断是否碰到坦克，只会判断是否碰到子弹和墙壁。

					还需要判断是否碰到子弹，碰到子弹后需要判断该坦克是否被击毁，并且删除子弹，并通知UI销毁子弹，
					    如果没有被击毁，则只是通知UI减少血量，
					    如果坦克被击毁，
					        如果是电脑坦克，则首先从computerTankList中删除之，
						    若删除后computerTankList为空，
						        （先认为电脑坦克们在销毁的过程中不会被新增，数量由多到少，后续进行优化，比如说，一个关卡电脑方有固定的坦克数量，每销毁一辆，则增加一辆，直到所有的坦克数量用完为止则不再增加），
						        现使用简化版的策略，即一开始生成坦克后不再增加，
						        所以一旦判断computerTankList为空，则认为电脑方失败，游戏结束，此时可以向消息队列发送endGame命令。
						    若删除后computerTankList不为空，则通知UI坦克被击毁。  
						如果是用户坦克，因为只有一辆，则向UI发送击毁信息，同时向消息队列发送endGame命令。
						
							
					还需要判断是否碰到坦克，
						如果是同为电脑坦克，则同时转向即可，
						如果是电脑坦克碰到了用户坦克，则会相互攻击，直到一方被消灭。

					
	如子弹移动，
				//需要判断是否碰到坦克，子弹击中后需要消失，应首先从stoneList中删除该stone，这样就不会再移动了，然后通知UI
			        //让对应子弹的panel消失。(9.1号添加，子弹不会去判断是否碰到坦克)
			      
				//包括敌方坦克：子弹消失，给敌方坦克造成一定的伤害.(9.1号添加，由敌方坦克自己判断)
				
				（//注：有一个问题：即子弹碰到了坦克这个事件是由谁来判断的，如果是两者都判断，虽然在现实中两者会同时判断，
				//但是，在程序中子弹的移动和坦克的移动是是有顺序的，也就是说，可能是子弹移动消息先判断到，
				//也可能是坦克移动消息先判断到，可以通过添加消息的方式，即向消息队列中添加坦克击中和子弹击中的消息，
				//并删除子弹，避免重复通知，
				）
				
				包括己方坦克：(9.1 judge by team tank)
				
				还需要判断是否碰到障碍物，如墙壁，(9.1: need to judge, if the stone move to wall, delete the stone 
				from the stoneList and notify UI to make the stone disappear)
				
				还需要判断是否碰到子弹：碰到子弹后应该相互抵消，(9.1: contains two situations:
				first, if the two 
				 
				)

				
	如startGame后生成地图和生成坦克，
				先生成地图：可以按照
				后生成坦克：	

	
	如endGame，可以让GameModel执行，也可以让消息队列执行，执行时需要：
					通知UI展示游戏结束界面；
					通知UI不再接收用户的请求，比如在想消息队列添加消息时，先判断一下游戏状态再去添加，若游戏已结束，则不再添加消息，UI的用户坦克自然不会再移动。
					结束子弹控制器和电脑坦克控制器线程。
				还需要考虑在endGame后用户重新打开游戏，此时GameModel，各个线程都需要重建，
				


	
3、关于通知UI，通过不同的消息通知UI，不同的消息携带不同的信息，如子弹被击毁和坦克被击毁。
	可以使用发布订阅的模式，UI订阅了GameModel的所有消息，接收消息后会进行判断，做相应的操作。
	
	
///////////////////////////////////////////////////////////////////////////////////////////
9.1号思考
1、关于子弹与坦克碰撞，子弹与子弹碰撞后谁执行碰撞操作的问题：
由于消息处理器是串行的，所以碰撞双方总有一个先检测到，就由先检测到碰撞的一方执行所有的操作，
而当后一方的移动消息被执行时（检测是由移动触发的），则会发现：
1）如果子弹和敌方坦克碰到：
1.1）坦克先检测到，则后一方子弹被坦克处理操作给删除掉，则执行子弹的移动消息时会发现相应的list中没有该对象，则不执行任何操作。
1.2）子弹先检测到，如果后一方被先检测一方进行了相应操作，
              如后一方坦克血量被减少，则该坦克移动时正常移动即可，因为子弹一定被删除。
              如后一方坦克被删除，则执行该坦克的移动消息时会发现，tankList中没有该对象，不执行任何操作。

2）如果子弹与己方坦克碰到（希望子弹消失，但是不对坦克造成伤害）：
2.1）坦克先检测到，则后一方子弹被删除掉，坦克不造成伤害，后续的子弹移动消息不执行任何操作。
2.2）子弹先检测到，则子弹自己被删除，则坦克移动时不会碰到子弹，不执行任何操作。


3）如果己方坦克碰到了一起，先检测到的执行双方转向操作，则后移动一方，不会检测到有坦克与己方坦克碰到了一起。

4）如果敌对坦克碰到了一起，首先是双方坦克的移动命令都不会执行，
             其次对于电脑坦克而言，检测到敌方坦克后会发射子弹，
                     这里引出一个问题和规则：不能没执行一次移动发现有攻击范围的坦克就去发射子弹，而是电脑坦克会有一个“自己正在运行的子弹”列表，
                                                       只有判断出自己的这个列表为空时才会继续发射子弹。
             而对于用户坦克而言，由用户控制发射子弹并移动，当然用户发起相向而行移动指令也不会操作，用户点击发射子弹，则会不断发射，
      
             这里引出一个问题和规则，即用户坦克和电脑坦克的子弹都是有限的，当然电脑坦克的子弹会更少一些，当子弹用完时，再想发射就没有子弹了。
             

5）子弹与子弹的碰撞
5.1）如果一方子弹先检测到，则会删除自己和后一方子弹，这样后一方子弹执行移动消息时会发现stoneList中没有自己，则不执行任何操作。

2、关于读写锁的问题：
读写的对象：stoneList和tankList；
具体读的线程包括：UI，stoneController，computerTankController；
具体写的线程包括：GameMsgExecutor；

所以需要给写线程要执行的GameModel中的所有写的方法加上synchronized关键字，写的时候不允许再读。


3、关于通知UI，维持原有的设计，即会有不同的消息。








	
	
	
	
	
	
	
	